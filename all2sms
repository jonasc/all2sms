#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import os
import logging as log
import stat
import sys
from configparser import ConfigParser
import threading

__version__ = '0.1.0'


class Recipient(object):
    recipients = []
    send_lock = threading.Lock()

    def __init__(self):
        log.debug('Recipient.__init__: append %s', self)
        Recipient.recipients.append(self)

    def _deliver(self, message):
        raise NotImplementedError('subclass has to implement deliver.')

    def _finalize(self):
        pass

    def send(message):
        log.debug('Recipient.send: sending %s', message)
        with Recipient.send_lock:
            for recipient in Recipient.recipients:
                recipient._deliver(message)

    def end():
        log.debug('Recipient.end')
        for recipient in Recipient.recipients:
            recipient._finalize()


class SmsModemRecipient(Recipient):
    def __init__(self, port, baudrate, number):
        super(SmsModemRecipient, self).__init__()

        from gsmmodem import GsmModem

        self.number = number
        self.modem = GsmModem(port, baudrate)
        self.modem.connect()
        log.info('Connected to gsm modem at %s @ %d', port, baudrate)

    def _deliver(self, message):
        log.info('Sending message to %s', self.number)
        self.smsTextMode = False
        self.modem.sendSms(self.number, message)

    def _finalize(self):
        log.debug('Closing connection to modem')
        self.modem.close()


class Watcher(threading.Thread):
    watchers = []

    def notify(self, message):
        Recipient.send(message)

    def __init__(self):
        self._running = True

        self._thread = threading.Thread(target=self.thread)
        self._thread.start()
        Watcher.watchers.append(self)

    def join():
        log.debug('Watcher.join')
        for watcher in Watcher.watchers:
            watcher._thread.join()

    def kill():
        log.debug('Watcher.kill')
        for watcher in Watcher.watchers:
            watcher._running = False
            watcher._kill()

    def _kill(self):
        pass

    def thread(self):
        raise NotImplementedError('Watcher subclass has to implement thread.')


class OtpWatcher(Watcher):
    def __init__(self, command):
        super(OtpWatcher, self).__init__()
        self.command = command.split()

    def thread(self):
        import subprocess
        import select
        self.process = subprocess.Popen(self.command,
                                        stdout=subprocess.PIPE,
                                        universal_newlines=True)
        old_otp = ''
        while self._running:
            if self.process.poll() is not None:
                self.process = subprocess.Popen(self.command,
                                                stdout=subprocess.PIPE,
                                                universal_newlines=True)

            # Try to read from stdout
            reads, _, _ = select.select([self.process.stdout], [], [], 1)
            if reads == []:
                continue

            otp = self.process.stdout.readline().strip()
            if otp == old_otp or otp == '':
                continue
            old_otp = otp
            Recipient.send('OTP: ' + otp)

    def _kill(self):
        if self.process.poll() is None:
            try:
                self.process.kill()
            except:
                pass


def main():
    #===========================================================================
    # Argument parsing
    #===========================================================================
    argparser = ArgumentParser(
        description='Monitor everything and notify mobile phone via SMS',
        add_help=False
    )
    # Getting help
    argparser.add_argument(
        '--help',
        action='help',
        help='show this help message and exit'
    )
    # Specifying config file
    argparser.add_argument(
        '-c', '--config',
        default='${XDG_CONFIG_HOME}/all2sms/all2sms.cfg',
        help='set the config file (default: %(default)s)'
    )
    # Logging options
    group_logging = argparser.add_argument_group('logging and output settings')
    group_logging.add_argument(
        '-l', '--log-file',
        default='${XDG_DATA_HOME}/all2sms/all2sms.log',
        help='set the log file (default: %(default)s)'
    )
    group = group_logging.add_mutually_exclusive_group()
    group.add_argument(
        '-v', '--verbose',
        dest='log_level',
        action='store_const',
        const=log.DEBUG,
        default=log.INFO,
        help='be verbose'
    )
    group.add_argument(
        '-q', '--quiet',
        dest='log_level',
        action='store_const',
        const=log.WARNING,
        help='don\'t output anything'
    )
    # Version
    argparser.add_argument(
        '--version',
        action='version',
        version='%(prog)s ' + __version__,
        help='show version information and exit'
    )

    # Parse the arguments
    args = argparser.parse_args()

    # Expand path variables and make paths absolute
    args.config = os.path.expandvars(args.config)
    if args.config.startswith('${XDG_CONFIG_HOME}'):
        args.config = args.config.replace('${XDG_CONFIG_HOME}',
                                          os.path.expanduser('~/.config'), 1)
    args.config = os.path.abspath(args.config)

    args.log_file = os.path.expandvars(args.log_file)
    if args.log_file.startswith('${XDG_DATA_HOME}'):
        args.log_file = args.log_file.replace(
            '${XDG_DATA_HOME}', os.path.expanduser('~/.local/share'), 1)
    args.log_file = os.path.abspath(args.log_file)

    #===========================================================================
    # Logging
    #===========================================================================

    # Create parent folders if file does not exist
    try:
        os.stat(args.log_file)
    except OSError:
        os.makedirs(os.path.dirname(args.log_file))

    # Logging configuration
    log.basicConfig(
        format='%(asctime)s - %(levelname)s: %(message)s',
        filename=args.log_file,
        filemode='a', level=args.log_level
    )

    log_handler = log.StreamHandler()
    log_handler.setLevel(args.log_level)
    log_handler.setFormatter(log.Formatter('%(levelname)s: %(message)s'))

    log.getLogger().addHandler(log_handler)

    # Start program
    log.info('Started')

    #===========================================================================
    # Config file
    #===========================================================================
    try:
        file_stat = os.stat(args.config)

        if (stat.S_IRGRP | stat.S_IROTH) & file_stat.st_mode != 0:
            log.critical('config file "%s" is group- or world-readable. Please '
                         '`chmod 400` or similar.', args.config)
            sys.exit(2)
    except OSError as e:
        if e.errno != 2:
            log.critical('file stat error - %s', e)
            sys.exit(1)
        else:
            log.warn('config file "%s" does not exist', args.config)

    config = ConfigParser()
    config.read_string('''
    [modem-sms]
    recipient=
    port=
    baudrate=115200
    [otp]
    command=
    ''')

    # Read config file
    config.read(args.config)

    critical_error = False

    # Exit if there are config values missing
    if len(config.get('modem-sms', 'recipient')) == 0:
        log.critical('no sms recipient specified')
        critical_error = True
    elif not config.get('modem-sms', 'recipient').startswith('+'):
        log.critical('sms recipient numbers has to be international')
        critical_error = True

    if len(config.get('modem-sms', 'port')) == 0:
        log.critical('no modem port specified')
        critical_error = True

    if len(config.get('otp', 'command')) == 0:
        log.critical('no otp command specified')
        critical_error = True

    if critical_error:
        log.error('critical errors with missing config options - exiting')
        sys.exit(1)

    #===========================================================================
    # The program
    #===========================================================================

    # Initialize recipient
    #---------------------------------------------------------------------------
    try:
        # Recipient via SMS
        SmsModemRecipient(config.get('modem-sms', 'port'),
                          config.getint('modem-sms', 'baudrate'),
                          config.get('modem-sms', 'recipient'))

        # Watch for new OTPs
        OtpWatcher(config.get('otp', 'command'))

        # Wait for all watchers to end
        Watcher.join()

    except KeyboardInterrupt:
        log.warn('Received keyboard interrupt - shutting down')
        Watcher.kill()
        sys.exit(1)

    finally:
        Recipient.end()


if __name__ == '__main__':
    main()
