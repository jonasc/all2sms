#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from argparse import ArgumentParser
import os
import logging as log
import stat
import sys
from configparser import ConfigParser
import threading
import re

__version__ = '0.1.0'


class Recipient(object):
    recipients = []
    send_lock = threading.Lock()

    def __init__(self):
        log.debug('Recipient.__init__: append %s', self)
        Recipient.recipients.append(self)

    def _deliver(self, message):
        raise NotImplementedError('subclass has to implement deliver.')

    def _finalize(self):
        pass

    def send(message):
        message = message.strip()
        log.debug('Recipient.send: sending %s', message)
        with Recipient.send_lock:
            for recipient in Recipient.recipients:
                recipient._deliver(message)

    def end():
        log.debug('Recipient.end')
        for recipient in Recipient.recipients:
            recipient._finalize()


class DummyRecipient(Recipient):
    def _deliver(self, message):
        log.info('Dummy.deliver: "{}"'.format(message))


class SmsModemRecipient(Recipient):
    def __init__(self, port, baudrate, number):
        super(SmsModemRecipient, self).__init__()

        from gsmmodem import GsmModem

        self.number = number
        self.modem = GsmModem(port, int(baudrate))
        self.modem.connect()
        log.info('Connected to gsm modem at %s @ %d', port, int(baudrate))

    def _deliver(self, message):
        log.info('Sending message to %s', self.number)
        self.smsTextMode = False
        self.modem.sendSms(self.number, message)

    def _finalize(self):
        log.debug('Closing connection to modem')
        self.modem.close()


class Watcher(object):
    watchers = []

    def notify(self, message):
        Recipient.send(message)

    def __init__(self):
        log.debug('Watcher.__init__: append %s', self)
        self._running = True

        self._thread = threading.Thread(target=self.thread)
        self._thread.start()
        Watcher.watchers.append(self)

    def join():
        log.debug('Watcher.join')
        for watcher in Watcher.watchers:
            watcher._thread.join()

    def kill():
        log.debug('Watcher.kill')
        for watcher in Watcher.watchers:
            watcher._running = False
            watcher._kill()

    def _kill(self):
        pass

    def thread(self):
        raise NotImplementedError('Watcher subclass has to implement thread.')


class OtpWatcher(Watcher):
    def __init__(self, command):
        self.command = command.split()

        super(OtpWatcher, self).__init__()

    def thread(self):
        import subprocess
        import select
        self.process = subprocess.Popen(self.command,
                                        stdout=subprocess.PIPE,
                                        universal_newlines=True)
        old_otp = ''
        while self._running:
            if self.process.poll() is not None:
                self.process = subprocess.Popen(self.command,
                                                stdout=subprocess.PIPE,
                                                universal_newlines=True)

            # Try to read from stdout
            reads, _, _ = select.select([self.process.stdout], [], [], 1)
            if reads == []:
                continue

            otp = self.process.stdout.readline().strip()
            if otp == old_otp or otp == '':
                continue
            old_otp = otp
            Recipient.send('OTP: ' + otp)

    def _kill(self):
        if self.process.poll() is None:
            try:
                self.process.kill()
            except:
                pass


class ImapWatcher(Watcher):
    folder_line_re = re.compile(
        r'\((?P<flags>.*?)\) "(?P<delimiter>.*)" (?P<name>.*)'
    )
    uid_re = re.compile(r'[0-9]+ \(UID (?P<uid>[0-9]+).*')

    def __init__(self, user, password, host, port, name):
        import imaplib
        self.conn = imaplib.IMAP4_SSL(host, port)
        self.conn.login(user, password)
        self.name = name

        super(ImapWatcher, self).__init__()

    def _parse_folder_line(line):
        if isinstance(line, bytes):
            line = line.decode()
        flags, delimiter, name = ImapWatcher.folder_line_re.match(line).groups()
        name = name.strip('"')
        return flags, delimiter, name

    def _decode_header(h):
        import email
        return ''.join(map(
            lambda x: x[0].decode(
                'utf-8' if x[1] is None else x[1]
            ) if isinstance(x[0], bytes) else x[0],
            email.header.decode_header(h)
        ))

    def thread(self):
        import time
        import email

        first_run = True
        old_unseen = set()
        unseen = set()
        while self._running:
            time.sleep(1)
            if not self._running:
                break

            old_unseen = unseen.copy()
            unseen = set()
            mapping = dict()

            ok, result = self.conn.list()
            if ok != 'OK':
                log.debug('ImapWatcher: LIST result "%s"', ok)
                continue

            for line in result:
                _, _, folder = ImapWatcher._parse_folder_line(line)
                self.conn.select(folder, readonly=True)
                ok, result = self.conn.search(None, '(UNSEEN)')
                if ok != 'OK':
                    continue
                ids = result[0].decode().split()
                if ids == []:
                    continue
                ok, result = self.conn.fetch(','.join(ids), '(UID RFC822)')
                if ok != 'OK':
                    continue
                for uid_rfc822 in result:
                    try:
                        uid, rfc822 = uid_rfc822
                    except:
                        continue
                    uid = ImapWatcher.uid_re.match(uid.decode()).group(1)
                    unseen.add(uid)
                    mapping[uid] = (folder, rfc822)

            if first_run:
                first_run = False
                continue

            difference = unseen - old_unseen
            if difference == set():
                continue

            for uid in difference:
                folder, rfc822 = mapping[uid]
                mail = email.message_from_bytes(rfc822)
                subject = ImapWatcher._decode_header(mail['subject'])
                subject = re.sub(r'\s+', ' ', subject)
                fr = ImapWatcher._decode_header(mail['from'])
                fr = re.sub(r'\s+', ' ', fr)
                content = ''
                for part in mail.walk():
                    if part.get_content_type() == 'text/plain':
                        content = part.get_payload(decode=True).decode(
                            part.get_content_charset())
                        break
                    if part.get_content_type() == 'multipart/encrypted':
                        content = '<encrypted message>'
                message = '{}/{}\r\n{}\r\n{}\r\n\r\n{}'.format(self.name,
                                                               folder, fr,
                                                               subject, content)
                Recipient.send(message)

    def _kill(self):
        try:
            self.conn.close()
        except:
            pass

        try:
            self.conn.logout()
        except:
            pass


def main():
    #===========================================================================
    # Argument parsing
    #===========================================================================
    argparser = ArgumentParser(
        description='Monitor everything and notify mobile phone via SMS',
        add_help=False
    )
    # Getting help
    argparser.add_argument(
        '--help',
        action='help',
        help='show this help message and exit'
    )
    # Specifying config file
    argparser.add_argument(
        '-c', '--config',
        default='${XDG_CONFIG_HOME}/all2sms/all2sms.cfg',
        help='set the config file (default: %(default)s)'
    )
    # Logging options
    group_logging = argparser.add_argument_group('logging and output settings')
    group_logging.add_argument(
        '-l', '--log-file',
        default='${XDG_DATA_HOME}/all2sms/all2sms.log',
        help='set the log file (default: %(default)s)'
    )
    group = group_logging.add_mutually_exclusive_group()
    group.add_argument(
        '-v', '--verbose',
        dest='log_level',
        action='store_const',
        const=log.DEBUG,
        default=log.INFO,
        help='be verbose'
    )
    group.add_argument(
        '-q', '--quiet',
        dest='log_level',
        action='store_const',
        const=log.WARNING,
        help='don\'t output anything'
    )
    # Version
    argparser.add_argument(
        '--version',
        action='version',
        version='%(prog)s ' + __version__,
        help='show version information and exit'
    )

    # Parse the arguments
    args = argparser.parse_args()

    # Expand path variables and make paths absolute
    args.config = os.path.expandvars(args.config)
    if args.config.startswith('${XDG_CONFIG_HOME}'):
        args.config = args.config.replace('${XDG_CONFIG_HOME}',
                                          os.path.expanduser('~/.config'), 1)
    args.config = os.path.abspath(args.config)

    args.log_file = os.path.expandvars(args.log_file)
    if args.log_file.startswith('${XDG_DATA_HOME}'):
        args.log_file = args.log_file.replace(
            '${XDG_DATA_HOME}', os.path.expanduser('~/.local/share'), 1)
    args.log_file = os.path.abspath(args.log_file)

    #===========================================================================
    # Logging
    #===========================================================================

    # Create parent folders if file does not exist
    try:
        os.stat(args.log_file)
    except OSError:
        os.makedirs(os.path.dirname(args.log_file))

    # Logging configuration
    log.basicConfig(
        format='%(asctime)s - %(levelname)s: %(message)s',
        filename=args.log_file,
        filemode='a', level=args.log_level
    )

    log_handler = log.StreamHandler()
    log_handler.setLevel(args.log_level)
    log_handler.setFormatter(log.Formatter('%(levelname)s: %(message)s'))

    log.getLogger().addHandler(log_handler)

    # Start program
    log.info('Started')

    #===========================================================================
    # Config file
    #===========================================================================
    try:
        file_stat = os.stat(args.config)

        if (stat.S_IRGRP | stat.S_IROTH) & file_stat.st_mode != 0:
            log.critical('config file "%s" is group- or world-readable. Please '
                         '`chmod 400` or similar.', args.config)
            sys.exit(2)
    except OSError as e:
        if e.errno != 2:
            log.critical('file stat error - %s', e)
            sys.exit(1)
        else:
            log.warn('config file "%s" does not exist', args.config)

    config = ConfigParser()
    config.read_string('''
    [general]
    backends=dummy
    watchers=
    [dummy]
    [sms-modem]
    number=
    port=
    baudrate=115200
    [otp]
    command=
    ''')

    # Read config file
    config.read(args.config)

    critical_error = False

    # Exit if there are config values missing
    if len(config.get('sms-modem', 'number')) == 0:
        log.critical('no sms recipient specified')
        critical_error = True
    elif not config.get('sms-modem', 'number').startswith('+'):
        log.critical('sms recipient numbers has to be international')
        critical_error = True

    if len(config.get('sms-modem', 'port')) == 0:
        log.critical('no modem port specified')
        critical_error = True

    if len(config.get('otp', 'command')) == 0:
        log.critical('no otp command specified')
        critical_error = True

    if critical_error:
        log.error('critical errors with missing config options - exiting')
        sys.exit(1)

    #===========================================================================
    # The program
    #===========================================================================

    # Initialize recipient
    #---------------------------------------------------------------------------
    try:
        for backend in config.get('general', 'backends').split():
            classname = re.sub(r'[^a-z]', '', backend.lower()) + 'recipient'
            log.debug('Found backend "%s" -> class "%s"', backend, classname)
            for subclass in Recipient.__subclasses__():
                if subclass.__name__.lower() == classname:
                    options = dict(config.items(backend))
                    log.debug('Creating "%s"', subclass.__name__)
                    subclass(**options)
                    break

        for watcher in config.get('general', 'watchers').split():
            classname = re.sub(r'[^a-z]', '', watcher.lower()) + 'watcher'
            log.debug('Found watcher "%s" -> class "%s"', watcher, classname)
            for subclass in Watcher.__subclasses__():
                if subclass.__name__.lower() == classname:
                    options = dict(config.items(watcher))
                    log.debug('Creating "%s"', subclass.__name__)
                    subclass(**options)
                    break

        # Wait for all watchers to end
        Watcher.join()

    except KeyboardInterrupt:
        log.warn('Received keyboard interrupt - shutting down')
        Watcher.kill()
        sys.exit(1)

    finally:
        Recipient.end()


if __name__ == '__main__':
    main()
